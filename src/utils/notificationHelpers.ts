import notificationService from "../services/notificationService";
import {
  NotificationType,
  NotificationPriority,
  TargetType,
} from "../types/notification.types";
import prisma from "../config/prisma";

/**
 * Notification Helpers for easy integration into existing controllers
 */

// Post-related notifications
export const notifyPostLike = async (postId: string, likedByUserId: string) => {
  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      select: { userId: true, content: true, mediaUrl: true },
    });

    if (!post || post.userId === likedByUserId) return; // Don't notify if user likes own post

    await notificationService.createNotification({
      userId: post.userId,
      actorId: likedByUserId,
      type: NotificationType.POST_LIKE,
      title: "Post Liked",
      message: "", // Will be generated by template
      targetId: postId,
      targetType: TargetType.POST,
      metadata: {
        postContent: post.content.substring(0, 100),
        imageUrl: post.mediaUrl[0] || undefined,
        actionUrl: `/posts/${postId}`,
      },
    });
  } catch (error) {
    console.error("Error sending post like notification:", error);
  }
};

export const notifyPostComment = async (
  postId: string,
  commentedByUserId: string,
  commentContent: string,
) => {
  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      select: { userId: true, content: true, mediaUrl: true },
    });

    if (!post || post.userId === commentedByUserId) return;

    await notificationService.createNotification({
      userId: post.userId,
      actorId: commentedByUserId,
      type: NotificationType.POST_COMMENT,
      title: "New Comment",
      message: "", // Will be generated by template
      targetId: postId,
      targetType: TargetType.POST,
      metadata: {
        postContent: post.content.substring(0, 100),
        imageUrl: post.mediaUrl[0] || undefined,
        actionUrl: `/posts/${postId}`,
        commentContent: commentContent.substring(0, 100),
      },
    });
  } catch (error) {
    console.error("Error sending post comment notification:", error);
  }
};

export const notifyPostShare = async (
  postId: string,
  sharedByUserId: string,
) => {
  try {
    const post = await prisma.post.findUnique({
      where: { id: postId },
      select: { userId: true, content: true, mediaUrl: true },
    });

    if (!post || post.userId === sharedByUserId) return;

    await notificationService.createNotification({
      userId: post.userId,
      actorId: sharedByUserId,
      type: NotificationType.POST_SHARE,
      title: "Post Shared",
      message: "", // Will be generated by template
      targetId: postId,
      targetType: TargetType.POST,
      metadata: {
        postContent: post.content.substring(0, 100),
        imageUrl: post.mediaUrl[0] || undefined,
        actionUrl: `/posts/${postId}`,
      },
    });
  } catch (error) {
    console.error("Error sending post share notification:", error);
  }
};

// Connection-related notifications
export const notifyConnectionRequest = async (
  fromUserId: string,
  toUserId: string,
) => {
  try {
    await notificationService.createNotification({
      userId: toUserId,
      actorId: fromUserId,
      type: NotificationType.CONNECTION_REQUEST,
      title: "Connection Request",
      message: "", // Will be generated by template
      targetId: fromUserId,
      targetType: TargetType.USER,
      metadata: {
        actionUrl: `/profile/${fromUserId}`,
      },
      priority: NotificationPriority.HIGH,
    });
  } catch (error) {
    console.error("Error sending connection request notification:", error);
  }
};

export const notifyConnectionAccepted = async (
  acceptedByUserId: string,
  requestorUserId: string,
) => {
  try {
    await notificationService.createNotification({
      userId: requestorUserId,
      actorId: acceptedByUserId,
      type: NotificationType.CONNECTION_ACCEPTED,
      title: "Connection Accepted",
      message: "", // Will be generated by template
      targetId: acceptedByUserId,
      targetType: TargetType.USER,
      metadata: {
        actionUrl: `/profile/${acceptedByUserId}`,
      },
      priority: NotificationPriority.HIGH,
    });
  } catch (error) {
    console.error("Error sending connection accepted notification:", error);
  }
};

// Message notifications
export const notifyNewMessage = async (
  fromUserId: string,
  toUserId: string,
  messageContent: string,
) => {
  try {
    await notificationService.createNotification({
      userId: toUserId,
      actorId: fromUserId,
      type: NotificationType.NEW_MESSAGE,
      title: "New Message",
      message: "", // Will be generated by template
      targetId: fromUserId,
      targetType: TargetType.MESSAGE,
      metadata: {
        actionUrl: `/messages/${fromUserId}`,
        messagePreview: messageContent.substring(0, 50),
      },
      priority: NotificationPriority.HIGH,
    });
  } catch (error) {
    console.error("Error sending new message notification:", error);
  }
};

// Story notifications
export const notifyStoryView = async (
  storyId: string,
  viewedByUserId: string,
) => {
  try {
    const story = await prisma.story.findUnique({
      where: { id: storyId },
      select: { userId: true, mediaUrl: true },
    });

    if (!story || story.userId === viewedByUserId) return;

    await notificationService.createNotification({
      userId: story.userId,
      actorId: viewedByUserId,
      type: NotificationType.STORY_VIEW,
      title: "Story View",
      message: "", // Will be generated by template
      targetId: storyId,
      targetType: TargetType.STORY,
      metadata: {
        imageUrl: story.mediaUrl,
        actionUrl: `/stories`,
      },
      priority: NotificationPriority.LOW,
    });
  } catch (error) {
    console.error("Error sending story view notification:", error);
  }
};

// Blog notifications
export const notifyBlogLike = async (blogId: string, likedByUserId: string) => {
  try {
    const blog = await prisma.blogs.findUnique({
      where: { id: blogId },
      select: { authorId: true, title: true },
    });

    if (!blog || blog.authorId === likedByUserId) return;

    await notificationService.createNotification({
      userId: blog.authorId,
      actorId: likedByUserId,
      type: NotificationType.BLOG_LIKE,
      title: "Blog Liked",
      message: "", // Will be generated by template
      targetId: blogId,
      targetType: TargetType.BLOG,
      metadata: {
        postContent: blog.title,
        // imageUrl: blog.titlePhoto || undefined,
        actionUrl: `/blogs/${blogId}`,
      },
    });
  } catch (error) {
    console.error("Error sending blog like notification:", error);
  }
};

// System notifications
export const notifyWelcomeUser = async (userId: string) => {
  try {
    await notificationService.createNotification({
      userId,
      type: NotificationType.WELCOME,
      title: "Welcome to Uniisphere!",
      message: "Welcome to Uniisphere! Complete your profile to get started.",
      metadata: {
        actionUrl: "/profile/edit",
      },
    });
  } catch (error) {
    console.error("Error sending welcome notification:", error);
  }
};

export const notifyAccountVerification = async (userId: string) => {
  try {
    await notificationService.createNotification({
      userId,
      type: NotificationType.ACCOUNT_VERIFICATION,
      title: "Account Verified",
      message: "Your account has been successfully verified!",
      priority: NotificationPriority.HIGH,
      metadata: {
        actionUrl: "/dashboard",
      },
    });
  } catch (error) {
    console.error("Error sending account verification notification:", error);
  }
};

export const notifyPasswordChanged = async (userId: string) => {
  try {
    await notificationService.createNotification({
      userId,
      type: NotificationType.PASSWORD_CHANGED,
      title: "Password Changed",
      message: "Your password has been successfully changed.",
      priority: NotificationPriority.HIGH,
      metadata: {
        actionUrl: "/profile/security",
      },
    });
  } catch (error) {
    console.error("Error sending password changed notification:", error);
  }
};

// Human Library notifications
export const notifyHumanLibMatch = async (
  userId: string,
  matchedWithUserId: string,
) => {
  try {
    await notificationService.createNotification({
      userId,
      actorId: matchedWithUserId,
      type: NotificationType.HUMAN_LIB_MATCHED,
      title: "Human Library Match",
      message: "You have been matched for an anonymous chat!",
      priority: NotificationPriority.HIGH,
      metadata: {
        actionUrl: "/human-library/chat",
      },
    });
  } catch (error) {
    console.error("Error sending human lib match notification:", error);
  }
};

// Batch notification helpers
export const notifyMultipleUsers = async (
  userIds: string[],
  type: NotificationType,
  actorId?: string,
  targetId?: string,
) => {
  try {
    await notificationService.createBatchNotifications({
      userIds,
      actorId,
      type,
      targetId,
      targetType: TargetType.POST, // Default, can be customized
    });
  } catch (error) {
    console.error("Error sending batch notifications:", error);
  }
};

// Profile view notification (for when someone views your profile)
export const notifyProfileView = async (
  profileOwnerId: string,
  viewedByUserId: string,
) => {
  try {
    // Only notify if they're not the same user and they're not already connected
    if (profileOwnerId === viewedByUserId) return;

    const connection = await prisma.connection.findFirst({
      where: {
        OR: [
          {
            userId1: profileOwnerId,
            userId2: viewedByUserId,
            status: "accepted",
          },
          {
            userId1: viewedByUserId,
            userId2: profileOwnerId,
            status: "accepted",
          },
        ],
      },
    });

    // Only notify if they're not connected (to avoid spam)
    if (connection) return;

    await notificationService.createNotification({
      userId: profileOwnerId,
      actorId: viewedByUserId,
      type: NotificationType.PROFILE_VIEW,
      title: "Profile View",
      message: "", // Will be generated by template
      targetId: viewedByUserId,
      targetType: TargetType.USER,
      metadata: {
        actionUrl: `/profile/${viewedByUserId}`,
      },
      priority: NotificationPriority.LOW,
    });
  } catch (error) {
    console.error("Error sending profile view notification:", error);
  }
};

