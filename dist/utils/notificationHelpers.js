"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.notifyProfileView = exports.notifyMultipleUsers = exports.notifyHumanLibMatch = exports.notifyPasswordChanged = exports.notifyAccountVerification = exports.notifyWelcomeUser = exports.notifyBlogLike = exports.notifyStoryView = exports.notifyNewMessage = exports.notifyConnectionAccepted = exports.notifyConnectionRequest = exports.notifyPostShare = exports.notifyPostComment = exports.notifyPostLike = void 0;
const notificationService_1 = __importDefault(require("../services/notificationService"));
const notification_types_1 = require("../types/notification.types");
const prisma_1 = __importDefault(require("../config/prisma"));
/**
 * Notification Helpers for easy integration into existing controllers
 */
// Post-related notifications
const notifyPostLike = (postId, likedByUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const post = yield prisma_1.default.post.findUnique({
            where: { id: postId },
            select: { userId: true, content: true, mediaUrl: true },
        });
        if (!post || post.userId === likedByUserId)
            return; // Don't notify if user likes own post
        yield notificationService_1.default.createNotification({
            userId: post.userId,
            actorId: likedByUserId,
            type: notification_types_1.NotificationType.POST_LIKE,
            title: "Post Liked",
            message: "", // Will be generated by template
            targetId: postId,
            targetType: notification_types_1.TargetType.POST,
            metadata: {
                postContent: post.content.substring(0, 100),
                imageUrl: post.mediaUrl[0] || undefined,
                actionUrl: `/posts/${postId}`,
            },
        });
    }
    catch (error) {
        console.error("Error sending post like notification:", error);
    }
});
exports.notifyPostLike = notifyPostLike;
const notifyPostComment = (postId, commentedByUserId, commentContent) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const post = yield prisma_1.default.post.findUnique({
            where: { id: postId },
            select: { userId: true, content: true, mediaUrl: true },
        });
        if (!post || post.userId === commentedByUserId)
            return;
        yield notificationService_1.default.createNotification({
            userId: post.userId,
            actorId: commentedByUserId,
            type: notification_types_1.NotificationType.POST_COMMENT,
            title: "New Comment",
            message: "", // Will be generated by template
            targetId: postId,
            targetType: notification_types_1.TargetType.POST,
            metadata: {
                postContent: post.content.substring(0, 100),
                imageUrl: post.mediaUrl[0] || undefined,
                actionUrl: `/posts/${postId}`,
                commentContent: commentContent.substring(0, 100),
            },
        });
    }
    catch (error) {
        console.error("Error sending post comment notification:", error);
    }
});
exports.notifyPostComment = notifyPostComment;
const notifyPostShare = (postId, sharedByUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const post = yield prisma_1.default.post.findUnique({
            where: { id: postId },
            select: { userId: true, content: true, mediaUrl: true },
        });
        if (!post || post.userId === sharedByUserId)
            return;
        yield notificationService_1.default.createNotification({
            userId: post.userId,
            actorId: sharedByUserId,
            type: notification_types_1.NotificationType.POST_SHARE,
            title: "Post Shared",
            message: "", // Will be generated by template
            targetId: postId,
            targetType: notification_types_1.TargetType.POST,
            metadata: {
                postContent: post.content.substring(0, 100),
                imageUrl: post.mediaUrl[0] || undefined,
                actionUrl: `/posts/${postId}`,
            },
        });
    }
    catch (error) {
        console.error("Error sending post share notification:", error);
    }
});
exports.notifyPostShare = notifyPostShare;
// Connection-related notifications
const notifyConnectionRequest = (fromUserId, toUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId: toUserId,
            actorId: fromUserId,
            type: notification_types_1.NotificationType.CONNECTION_REQUEST,
            title: "Connection Request",
            message: "", // Will be generated by template
            targetId: fromUserId,
            targetType: notification_types_1.TargetType.USER,
            metadata: {
                actionUrl: `/profile/${fromUserId}`,
            },
            priority: notification_types_1.NotificationPriority.HIGH,
        });
    }
    catch (error) {
        console.error("Error sending connection request notification:", error);
    }
});
exports.notifyConnectionRequest = notifyConnectionRequest;
const notifyConnectionAccepted = (acceptedByUserId, requestorUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId: requestorUserId,
            actorId: acceptedByUserId,
            type: notification_types_1.NotificationType.CONNECTION_ACCEPTED,
            title: "Connection Accepted",
            message: "", // Will be generated by template
            targetId: acceptedByUserId,
            targetType: notification_types_1.TargetType.USER,
            metadata: {
                actionUrl: `/profile/${acceptedByUserId}`,
            },
            priority: notification_types_1.NotificationPriority.HIGH,
        });
    }
    catch (error) {
        console.error("Error sending connection accepted notification:", error);
    }
});
exports.notifyConnectionAccepted = notifyConnectionAccepted;
// Message notifications
const notifyNewMessage = (fromUserId, toUserId, messageContent) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId: toUserId,
            actorId: fromUserId,
            type: notification_types_1.NotificationType.NEW_MESSAGE,
            title: "New Message",
            message: "", // Will be generated by template
            targetId: fromUserId,
            targetType: notification_types_1.TargetType.MESSAGE,
            metadata: {
                actionUrl: `/messages/${fromUserId}`,
                messagePreview: messageContent.substring(0, 50),
            },
            priority: notification_types_1.NotificationPriority.HIGH,
        });
    }
    catch (error) {
        console.error("Error sending new message notification:", error);
    }
});
exports.notifyNewMessage = notifyNewMessage;
// Story notifications
const notifyStoryView = (storyId, viewedByUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const story = yield prisma_1.default.story.findUnique({
            where: { id: storyId },
            select: { userId: true, mediaUrl: true },
        });
        if (!story || story.userId === viewedByUserId)
            return;
        yield notificationService_1.default.createNotification({
            userId: story.userId,
            actorId: viewedByUserId,
            type: notification_types_1.NotificationType.STORY_VIEW,
            title: "Story View",
            message: "", // Will be generated by template
            targetId: storyId,
            targetType: notification_types_1.TargetType.STORY,
            metadata: {
                imageUrl: story.mediaUrl,
                actionUrl: `/stories`,
            },
            priority: notification_types_1.NotificationPriority.LOW,
        });
    }
    catch (error) {
        console.error("Error sending story view notification:", error);
    }
});
exports.notifyStoryView = notifyStoryView;
// Blog notifications
const notifyBlogLike = (blogId, likedByUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const blog = yield prisma_1.default.blogs.findUnique({
            where: { id: blogId },
            select: { authorId: true, title: true },
        });
        if (!blog || blog.authorId === likedByUserId)
            return;
        yield notificationService_1.default.createNotification({
            userId: blog.authorId,
            actorId: likedByUserId,
            type: notification_types_1.NotificationType.BLOG_LIKE,
            title: "Blog Liked",
            message: "", // Will be generated by template
            targetId: blogId,
            targetType: notification_types_1.TargetType.BLOG,
            metadata: {
                postContent: blog.title,
                // imageUrl: blog.titlePhoto || undefined,
                actionUrl: `/blogs/${blogId}`,
            },
        });
    }
    catch (error) {
        console.error("Error sending blog like notification:", error);
    }
});
exports.notifyBlogLike = notifyBlogLike;
// System notifications
const notifyWelcomeUser = (userId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId,
            type: notification_types_1.NotificationType.WELCOME,
            title: "Welcome to Uniisphere!",
            message: "Welcome to Uniisphere! Complete your profile to get started.",
            metadata: {
                actionUrl: "/profile/edit",
            },
        });
    }
    catch (error) {
        console.error("Error sending welcome notification:", error);
    }
});
exports.notifyWelcomeUser = notifyWelcomeUser;
const notifyAccountVerification = (userId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId,
            type: notification_types_1.NotificationType.ACCOUNT_VERIFICATION,
            title: "Account Verified",
            message: "Your account has been successfully verified!",
            priority: notification_types_1.NotificationPriority.HIGH,
            metadata: {
                actionUrl: "/dashboard",
            },
        });
    }
    catch (error) {
        console.error("Error sending account verification notification:", error);
    }
});
exports.notifyAccountVerification = notifyAccountVerification;
const notifyPasswordChanged = (userId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId,
            type: notification_types_1.NotificationType.PASSWORD_CHANGED,
            title: "Password Changed",
            message: "Your password has been successfully changed.",
            priority: notification_types_1.NotificationPriority.HIGH,
            metadata: {
                actionUrl: "/profile/security",
            },
        });
    }
    catch (error) {
        console.error("Error sending password changed notification:", error);
    }
});
exports.notifyPasswordChanged = notifyPasswordChanged;
// Human Library notifications
const notifyHumanLibMatch = (userId, matchedWithUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createNotification({
            userId,
            actorId: matchedWithUserId,
            type: notification_types_1.NotificationType.HUMAN_LIB_MATCHED,
            title: "Human Library Match",
            message: "You have been matched for an anonymous chat!",
            priority: notification_types_1.NotificationPriority.HIGH,
            metadata: {
                actionUrl: "/human-library/chat",
            },
        });
    }
    catch (error) {
        console.error("Error sending human lib match notification:", error);
    }
});
exports.notifyHumanLibMatch = notifyHumanLibMatch;
// Batch notification helpers
const notifyMultipleUsers = (userIds, type, actorId, targetId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield notificationService_1.default.createBatchNotifications({
            userIds,
            actorId,
            type,
            targetId,
            targetType: notification_types_1.TargetType.POST, // Default, can be customized
        });
    }
    catch (error) {
        console.error("Error sending batch notifications:", error);
    }
});
exports.notifyMultipleUsers = notifyMultipleUsers;
// Profile view notification (for when someone views your profile)
const notifyProfileView = (profileOwnerId, viewedByUserId) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // Only notify if they're not the same user and they're not already connected
        if (profileOwnerId === viewedByUserId)
            return;
        const connection = yield prisma_1.default.connection.findFirst({
            where: {
                OR: [
                    {
                        userId1: profileOwnerId,
                        userId2: viewedByUserId,
                        status: "accepted",
                    },
                    {
                        userId1: viewedByUserId,
                        userId2: profileOwnerId,
                        status: "accepted",
                    },
                ],
            },
        });
        // Only notify if they're not connected (to avoid spam)
        if (connection)
            return;
        yield notificationService_1.default.createNotification({
            userId: profileOwnerId,
            actorId: viewedByUserId,
            type: notification_types_1.NotificationType.PROFILE_VIEW,
            title: "Profile View",
            message: "", // Will be generated by template
            targetId: viewedByUserId,
            targetType: notification_types_1.TargetType.USER,
            metadata: {
                actionUrl: `/profile/${viewedByUserId}`,
            },
            priority: notification_types_1.NotificationPriority.LOW,
        });
    }
    catch (error) {
        console.error("Error sending profile view notification:", error);
    }
});
exports.notifyProfileView = notifyProfileView;
